# README

## Description

This project implements two programs to calculate the dot product of two vectors of real numbers. The first program is sequential, and the second is concurrent, using multiple threads to divide the computation. The input for the concurrent program is the output from the sequential program.

The main goal is to design, implement, and evaluate a concurrent solution for calculating the dot product of two real-number vectors.

## How the Programs Work

1. **Sequential Program (`produto_interno_seq.c`)**:
   - Generates two random vectors of size `N` (using the `float` type).
   - Writes the value of `N`, the two vectors, and their dot product result to a binary file.
   - The dot product is computed using the formula:
     \[
     a_1b_1 + a_2b_2 + \dots + a_Nb_N
     \]
   - The result is stored in the same binary file, following the vectors.

2. **Concurrent Program (`produto_interno_conc.c`)**:
   - Takes the number of threads `T` and the name of the binary file as input.
   - Loads the vectors and their dimension `N` from the binary file.
   - Divides the computation of the dot product across the `T` threads to perform the calculation concurrently.
   - After completing the computation, it compares the calculated dot product with the one stored in the binary file to check correctness.

3. **Execution and Compilation**:
   - Both programs are compiled with the flags `-Wall` and `-pthread` for enabling compiler warnings and thread support, respectively.

## Compilation

To compile the programs, run the following commands:

```bash
gcc -o produto_interno_seq.c produto_interno_seq -Wall
gcc -o produto_interno_conc.c produto_interno_conc -Wall -pthread 
```

The `-Wall` flag enables all compiler warnings to ensure the code is clean and free from common mistakes. The `-pthread` flag links the program with the POSIX threads library to enable multi-threading for the concurrent version.

## Running the Programs

### 1. Run the Sequential Program

To generate the input binary file with the two vectors and their dot product result, execute the following command:

```bash
./produto_interno_seq <dimension> <binary_out_file_name>
```

This will generate a binary file containing the dimension `N`, the two vectors, and the computed dot product.

### 2. Run the Concurrent Program

Once the binary file is generated by the sequential program, you can run the concurrent program by passing the number of threads and the file name as arguments:

```bash
./produto_interno_conc <number_of_threads> <binary_file_name>
```

This will load the vectors and their dimension from the binary file, calculate the dot product using the specified number of threads, and compare the result with the value stored in the file.

## Output

The program will output the calculated dot product and its comparison with the result from the sequential program. If the result matches, it indicates that the concurrent computation was successful. The program will also output the relative error between the sequential and concurrent results.

### Relative Error Formula

The relative error is calculated using the following formula:

\[
e = \frac{|vs - vc|}{vs}
\]

Where:
- `vs` is the result from the sequential program.
- `vc` is the result from the concurrent program.

## Evaluation

The concurrent program's performance and accuracy are evaluated by comparing the results with the sequential program and measuring the relative error. Additionally, performance metrics such as speedup can be calculated by comparing the execution time of the sequential and concurrent versions for varying numbers of threads.

## Files

- `produto_interno_seq.c`: Sequential implementation to calculate the dot product and generate the input file.
- `produto_interno_conc.c`: Concurrent implementation to calculate the dot product using multiple threads.
- `Makefile` (optional): A file to simplify the compilation process with proper flags.
  
## Conclusion

This project demonstrates the use of concurrency to improve the performance of a mathematical operation (dot product of two vectors) by dividing the workload among multiple threads. By comparing the concurrent and sequential results, we can evaluate the effectiveness of the concurrent solution.


